In this section we evaluate our local recovery technique. 

To show that our local recovery algorithm is sufficiently general, we implemented it for three different concurrent internal BSTs, namely those based on:
\begin{enumerate*}[label=(\roman*)]
\item the lock-free BST by Howley and Jones~\cite{HowJon:2012:SPAA}, denoted by \HJBST{},
\item the lock-based BST by Ramachandran and Mittal~\cite{RamMit:2015:PPoPP}, denoted by \CASTLE{} and
\item the RCU (Read-Copy-Update) lock-based BST by Arbel and Attiya~\cite{ArbAtt:2014:PODC}, denoted by \CITRUS{}.
\end{enumerate*}
These implementations were chosen so that we covered both lock-free and lock-based approaches. We choose two lock-based implementations as one is based on locking edges~\cite{RamMit:2015:PPoPP} and the other is based on locking nodes using RCU framework~\cite{ArbAtt:2014:PODC}.

Usually uniform key distribution (where all keys have same frequency of occurrence) have been used to evaluate concurrent BSTs. But in many of the real world workloads, keys have skewed distribution~\cite{ClaSha+:2009:SIAM} where some keys are more popular than others. Zipfian distribution, a type of power-law distribution simulates this behaviour~\cite{BreCao+:1999:INFOCOM,FalJag:1992:VLDB,GraSun+:1994:SIGMOD}. It is characterized by a parameter $\alpha$ which usually lies between 0.5 and 1~\cite{BreCao+:1999:INFOCOM,AdaHub:2002:GLOTTMET}. In our experiments we used both uniform and Zipfian distributions to evaluate the local recovery algorithm.

To better understand the effect of local recovery, we also measure \emph{seek time} which is defined as the total time an operation spends on tree traversal including all restarts as well as stack processing time. For both uniform and Zipfian distribution \CASTLE{} and \HJBST{} reached peak performance at 244 threads while \CITRUS{} reached its peak performance at 61 threads for smaller trees and at 122 and 183 threads for larger trees. Performance comparison of these algorithms is not shown here as we are more interested in studying the impact of our local recovery algorithm on each of these algorithms. 

For uniform distribution, the performance gain is marginal and, in many cases, is actually slightly worse due to the overhead of stack maintenance (graphs are provided in the appendix). This is not surprising because, for small trees, even though contention is higher, seek time is small to begin with and any benefit of local recovery is nullified by additional overhead of stack maintenance. For larger trees, even though seek time is larger, contention is low as key accesses are spread evenly. 

\input{c06/localRecovery/experiments-graphs-stampede-threadSweep-zipf-4Set-Relative-10threads}
\input{c06/localRecovery/experiments-graphs-stampede-threadSweep-zipf-4Set-Relative-seekTime-10threads}

\Figref{localRecovery-throughput-stampede-threadSweep-zipf-4Set-Relative} shows the behaviour for Zipfian distribution with $\alpha$=1. In general, Zipfian distribution causes more contention than uniform distribution. So even for small trees for which seek times are smaller, we still see performance gains for mixed and write-dominated workloads. \Figref{localRecovery-seekTime-stampede-threadSweep-zipf-4Set-Relative} shows how seek time improves (reduces) due to local recovery. 

From \figsrefc[ \& ]{localRecovery-throughput-stampede-threadSweep-zipf-4Set-Relative}{localRecovery-seekTime-stampede-threadSweep-zipf-4Set-Relative}, we see a clear correlation between seek time and system throughput. As seek time reduces due to local recovery, the system throughput also improves. We see maximum improvement for \HJBST{}. Since \CASTLE{} and \CITRUS{} are lock-based algorithms, no helping is performed during tree traversal.  But in \HJBST{}, during the tree traversal, if a pending operation is seen it is helped and then the current operation is restarted. This results in frequent restarts and hence local recovery improves performance by a larger margin.

\Tabref{localRecovery-perf-numbers} summarizes the performance gap (with respect to system throughput) between the base algorithm and its extension using local recovery for uniform and Zipfian distributions. 
\input{Figures/localRecovery/perf-numbers}